"""Assignment 1 - Grocery Store Events (Task 2)

CSC148 Winter 2024
Department of Computer Science,
University of Toronto

This code is provided solely for the personal and private use of
students taking the CSC148 course at the University of Toronto.
Copying for purposes other than this use is expressly prohibited.
All forms of distribution of this code, whether as given or with
any changes, are expressly prohibited.

All of the files in this directory are
Copyright (c) Jonathan Calver, Diane Horton, Sophia Huynh, Joonho Kim and
Jacqueline Smith.

Module Description:

When you are done Task 2, this file should contain all the classes
necessary to model the different kinds of events in the simulation.
"""
from __future__ import annotations

from io import StringIO
from typing import TextIO
from store import GroceryStore, Customer, Item, NoAvailableLineError


class Event:
    """An event in our grocery store simulation.

    Events have an ordering based on the event timestamp. For any two events
    e1 and e2, e1 < e2 iff event e1 has a timestamp that is less than event e2.
    This signifies that e1 happens before e2.

    This is an abstract class and should not be instantiated.

    Attributes:
    - timestamp: The time when this event occurs.

    Representation Invariants:
    - timestamp >= 0
    """
    timestamp: int

    def __init__(self, timestamp: int) -> None:
        """Initialize an Event with a given timestamp.

        Preconditions:
            - timestamp >= 0

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    # The following three methods allow for comparison of Event instances
    # using the standard comparison operators, such as ==, <, and <=.
    # All methods simply perform the desired comparison on the 'timestamp'
    # attribute of the two events.
    def __eq__(self, other: Event) -> bool:
        """Return whether this Event is equal to <other>.

        Two events are equal iff they have the same timestamp.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __lt__(self, other: Event) -> bool:
        """Return True iff this Event is less than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other: Event) -> bool:
        """Return True iff this Event is less than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event as specified in the A1 handout, and return any
        events generated by doing so.
        """
        raise NotImplementedError


class CustomerArrival(Event):
    """A customer arrives at the checkout area ready to join a line and
    check out.

    Attributes:
    - customer: The arriving customer
    """

    timestamp: int
    customer: Customer

    def __init__(self, timestamp: int, c: Customer) -> None:
        """Initialize a CustomerArrival event with the given <timestamp>
        and customer <c>.

        If the customer's arrival time is None, set it now to record
        the fact that this is the time when they first arrived at the
        checkout area. (This is the start of their waiting time.)

        Preconditions:
        - timestamp >= 0
        """
        Event.__init__(self, timestamp)
        self.customer = c
        if self.customer.arrival_time is None:
            self.customer.arrival_time = timestamp

    def __str__(self) -> str:
        return f'{self.timestamp} CustomerArrival {self.customer.name}' \
               f' ({self.customer.num_items()} items; ' \
               f'total checkout time {self.customer.item_time()})'

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event as specified in the A1 handout, and return any
        events generated by doing so.
        """
        try:
            # returns the line, cx enters
            checkout_line = store.enter_line(self.customer)
            # check if this line was empty before cx entered return a new cx
            # enters
            if len(store.all_lines[checkout_line]) - 1 == 0:
                return [CheckoutStarted(self.timestamp, checkout_line)]
            # if a line is available but a cx is already there in the line
            else:
                return []
            # if checkout_line is NoAvailableLine error
            # return CustomerArrival event with timestamp + 1
        except NoAvailableLineError:
            return [CustomerArrival(self.timestamp + 1, self.customer)]


class CheckoutStarted(Event):
    """A customer starts the checkout process in a particular checkout line.

    Attributes:
    - line_number: The number of the checkout line.
    """
    timestamp: int
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CheckoutStarted event with the given <timestamp>
        and <line_number>.

        Preconditions:
        - timestamp >= 0
        - line_number >= 0
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def __str__(self) -> str:
        return f'{self.timestamp} Checkout Started at line {self.line_number}'

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event as specified in the A1 handout, and return any
        events generated by doing so.

        # 333_10 capacity 2
        >>> config_file_name = 'input_files/config_333_10.json'
        >>> config_file = open(config_file_name)
        >>> s1 = GroceryStore(config_file)
        >>> config_file.close()
        >>>
        >>> item_list = [Item('bananas', 7)]
        >>> i1 = Item('bananas', 7)
        >>> i2 = Item('cheese', 2)
        >>> i3 = Item('mango', 3)
        >>> i4 = Item('apple', 1)
        >>> i5 = Item('onion', 7)
        >>> i6 = Item('tomato', 2)
        >>> i7 = Item('ginger', 7)
        >>> i8 = Item('pasta', 9)
        >>>
        >>> b1 = Customer('B1', item_list) # 7
        >>> b2 = Customer('B2', [i2]) # 2
        >>> b3 = Customer('B3', [i1, i2, i3, i4, i5, i6, i7, i8]) # 38
        >>> b4 = Customer('B4', [i3, i4]) # 4
        >>> b5 = Customer('B5', [i1, i2, i3, i4, i5, i6, i7, i8]) # 38
        >>> b6 = Customer('B6', [i1, i2, i3, i4, i5, i6, i7, i8]) #38
        >>> b7 = Customer('B7', [i8]) # 9
        >>> b8 = Customer('B8', [i2, i3]) # 5

        >>> s1.enter_line(b1)
        0
        >>> s1.enter_line(b2)
        1
        >>> s1.enter_line(b3)
        2
        >>> s1.enter_line(b5)
        6
        >>> s1.enter_line(b4)
        3
        >>> s1.enter_line(b6)
        7
        >>> s1.enter_line(b7)
        4
        >>> s1.enter_line(b6)
        8
        >>> s1.enter_line(b6)
        0
        >>> s1.enter_line(b1)
        5
        >>> s1.enter_line(b6)
        1

        >>> e1 = CheckoutStarted(10, 0)
        >>> e1.do(s1)[0].timestamp
        17
        >>> e2 = CheckoutStarted(10, 2)
        >>> e2.do(s1)[0].timestamp
        48
        >>> e3 = CheckoutStarted(5, 8)
        >>> e3.do(s1)[0].timestamp
        81
        >>> e4 = CheckoutStarted(5, 4)
        >>> e4.do(s1)[0].timestamp
        14

        """
        # cx who is first in <line number>
        cx = store.first_in_line(self.line_number)

        # time taken to check out cx who is in front of the <line number>
        checkout_time = store.next_checkout_time(self.line_number)
        total_checkout_time = self.timestamp + checkout_time
        return [CheckoutCompleted(total_checkout_time, self.line_number, cx)]


class CheckoutCompleted(Event):
    """A customer finishes the checkout process.

    Attributes:
    - line_number: The number of the checkout line where a customer
      is finishing.
    - customer: The finishing customer.
    """
    timestamp: int
    line_number: int
    customer: Customer

    def __init__(self, timestamp: int, line_number: int, c: Customer) -> None:
        """Initialize a CheckoutCompleted event.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number
        self.customer = c

    def __str__(self) -> str:
        return f'{self.timestamp} CheckoutCompleted {self.customer.name}' \
               f' ({self.customer.num_items()} items; total checkout time ' \
               f'{self.customer.item_time()})'

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event as specified in the A1 handout, and return any
        events generated by doing so.
        # 333_10 capacity 3
        >>> config_file_name = 'input_files/config_333_10.json'

        >>> config_file = open(config_file_name)
        >>> s1 = GroceryStore(config_file)
        >>> config_file.close()

        >>> item_list = [Item('bananas', 7)]
        >>> i1 = Item('bananas', 7)
        >>> i2 = Item('cheese', 2)
        >>> i3 = Item('mango', 3)
        >>> i4 = Item('apple', 1)
        >>> i5 = Item('onion', 7)
        >>> i6 = Item('tomato', 2)
        >>> i7 = Item('ginger', 7)
        >>> i8 = Item('pasta', 9)

        >>> b1 = Customer('B1', item_list)
        >>> b2 = Customer('B2', item_list)
        >>> b3 = Customer('B3', [i1, i2, i3, i4, i5, i6, i7, i8])
        >>> b4 = Customer('B4', item_list)
        >>> b5 = Customer('B5', [i1, i2, i3, i4, i5, i6, i7, i8])
        >>> b6 = Customer('B6', [i1, i2, i3, i4, i5, i6, i7, i8])
        >>> b7 = Customer('B7', item_list)
        >>> b8 = Customer('B8', item_list)

        >>> s1.enter_line(b1)
        0
        >>> s1.enter_line(b2)
        1
        >>> s1.enter_line(b3)
        2
        >>> s1.enter_line(b4)
        3
        >>> s1.enter_line(b5)
        6
        >>> s1.enter_line(b6)
        7
        >>> s1.enter_line(b7)
        4
        >>> s1.enter_line(b6)
        8
        >>> s1.enter_line(b6)
        0
        >>> s1.enter_line(b1)
        5
        >>> s1.enter_line(b2)
        1
        >>> s1.enter_line(b6)
        2
        >>> s1.enter_line(b3)
        6
        >>> s1.enter_line(b3)
        7
        >>> s1.enter_line(b5)
        8
        >>> s1.enter_line(b3)
        0
        >>> s1.enter_line(b6)
        1

        >>> e1 = CheckoutCompleted(10, 0, b1)
        >>> e1.do(s1)[0].timestamp
        10
        >>> e2 = CheckoutCompleted(10, 0, b6)
        >>> e2.do(s1)[0].timestamp
        10
        >>> e3 = CheckoutCompleted(10, 0, b3)
        >>> e3.do(s1)
        []
        """

        # remove the cx who was in front of the line
        remaining_cx_in_line = store.remove_front_customer(self.line_number)

        if remaining_cx_in_line == 0:
            return []
        else:
            return [CheckoutStarted(self.timestamp, self.line_number)]


class CloseLine(Event):
    """A CheckoutLine gets closed.

    Attributes:
    - line_number: The number of the checkout line.
    """
    timestamp: int
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CloseLine event.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def __str__(self) -> str:
        return f'{self.timestamp} CloseLine {self.line_number}'

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event as specified in the A1 handout, and return any
        events generated by doing so.

        # change 333_10 to 100_04

        >>> config_file_name = 'input_files/config_333_10.json'
        >>> config_file = open(config_file_name)
        >>> s1 = GroceryStore(config_file)
        >>> config_file.close()
        >>>
        >>> item_list = [Item('bananas', 7)]
        >>> i1 = Item('bananas', 7)
        >>> i2 = Item('cheese', 2)
        >>> i3 = Item('mango', 3)
        >>> i4 = Item('apple', 1)
        >>> i5 = Item('onion', 7)
        >>> i6 = Item('tomato', 2)
        >>> i7 = Item('ginger', 7)
        >>> i8 = Item('pasta', 9)
        >>>
        >>> a = Customer('A', item_list) # 7
        >>> b = Customer('B', [i2]) # 2
        >>> c = Customer('C', [i1, i2, i3, i4, i5, i6, i7, i8]) # 38
        >>> d = Customer('D', [i3, i4]) # 4
        >>> s1.enter_line(a)
        0
        >>> s1.enter_line(b)
        0
        >>> s1.enter_line(c)
        0
        >>> s1.enter_line(d)
        0
        """
        # first cx in the line
        # first_cx = store.first_in_line(self.line_number)
        # events = [CheckoutStarted(self.timestamp, self.line_number)]

        # one CustomerArrival event per cx in the line except first cx last
        # cx in line has cx arrival event with same time as CloseLine
        # <self.timestamp> next cx's timestamp inc by 1

        # lst of removed customers when the line is closed
        removed_cx = store.close_line(self.line_number)
        removed_cx.reverse()
        time = self.timestamp - 1
        events = []

        for cx in removed_cx:
            time += 1

            events.append(CustomerArrival(time, cx))
        return events


EVENT_SAMPLE = StringIO("""121 Arrive William Bananas 7
22 Arrive Trevor Flowers 22 Bread 3 Cheese 3 Cheese 3
41 Close 0""")


def create_event_list(event_file: TextIO) -> list[Event]:
    """Return a list of Event objects to represent the events in <filename>.

    The events in the list must be in the same order as they are in the file.

    Preconditions:
    - <event_file> is open.
    - <event_file> is in the format specified by the assignment handout.

    >>> samp_events = create_event_list(EVENT_SAMPLE)
    >>> len(samp_events) == 3
    True
    >>> isinstance(samp_events[0], CustomerArrival)
    True
    >>> isinstance(samp_events[2], CloseLine)
    True
    >>> event_file2 = 'input_files/events_base.txt'
    >>> with open(event_file2, 'r') as event_file2:
    ...     content = event_file2.read()
    >>> event_file2 = StringIO(content)
    >>> event_lst = create_event_list(event_file2)
    >>> len(event_lst)
    7
    """
    content = event_file.read()
    lines = content.split('\n')
    events_lst = []

    for line in lines:
        my_event = line.split()

        if not my_event:
            continue

        if my_event[1] == 'Arrive':
            timestamp = int(my_event[0])
            cx_name = my_event[2]
            items_in_line = my_event[3:]
            items = []
            for i in range(0, len(items_in_line), 2):
                items.append(Item(items_in_line[i], int(items_in_line[i + 1])))
            cx = Customer(cx_name, items)
            events_lst.append(CustomerArrival(timestamp, cx))
        else:
            timestamp = int(my_event[0])
            line_index = int(my_event[2])
            events_lst.append(CloseLine(timestamp, line_index))
    return events_lst


if __name__ == '__main__':
    import doctest

    doctest.testmod()

    check_pyta = True
    if check_pyta:
        import python_ta

        python_ta.check_all(config={
            'allowed-import-modules': ['__future__', 'typing', 'store',
                                       'python_ta', 'doctest', 'io']})
